# Story 1.2: Implement Live Data Capture Utility

## Status
Draft

## Story
**As a** data engineer,
**I want** to capture live market data from the Binance WebSocket stream,
**so that** we can create a "golden sample" for validation purposes to ensure the fidelity of our reconstructed data

## Acceptance Criteria
1. A Python script exists that can connect to the Binance combined WebSocket stream for BTC-USDT (`btcusdt@trade` and `btcusdt@depth@100ms`)
2. The script saves raw, interleaved JSON messages to a local file with proper timestamp annotation
3. The capture utility can be configured to run for a specified duration (e.g., 24 hours)
4. The captured data serves as a "golden sample" for validation against reconstructed historical data
5. The script follows the established project architecture and coding standards

## Tasks / Subtasks
- [ ] Task 1: Create capture module structure and dependencies (AC: 1, 5)
  - [ ] Create the capture module directory structure under `src/rlx_datapipe/capture/`
  - [ ] Add WebSocket dependencies to Poetry configuration (websockets library)
  - [ ] Set up logging configuration for the capture component
- [ ] Task 2: Implement WebSocket connection and message handling (AC: 1, 2)
  - [ ] Create WebSocket client class to connect to Binance combined stream
  - [ ] Implement message parsing and validation for trade and depth events
  - [ ] Add connection recovery and error handling for network issues
- [ ] Task 3: Implement data capture and storage (AC: 2, 4)
  - [ ] Create file writer to save raw JSON messages with timestamps
  - [ ] Implement proper file naming convention with timestamp information
  - [ ] Add data validation to ensure captured messages conform to expected schema
- [ ] Task 4: Create CLI interface and configuration (AC: 3, 5)
  - [ ] Create command-line script in `scripts/` directory for running capture
  - [ ] Add configuration options for duration, symbol, and output directory
  - [ ] Implement graceful shutdown handling (SIGINT, SIGTERM)
- [ ] Task 5: Write comprehensive tests (AC: all)
  - [ ] Create test file `tests/capture/test_live_capture.py`
  - [ ] Write unit tests for WebSocket connection handling using mocks
  - [ ] Write tests for message parsing and file writing functionality
  - [ ] Write integration tests for the complete capture workflow

## Dev Notes

### Previous Story Insights
[Source: Story 1.1 completion]
- The project uses Poetry for dependency management with Python 3.10+
- Loguru is established for logging across the project
- The analysis module pattern is already established and should be followed
- Code quality standards are enforced with Black formatting and Ruff linting

### Data Models
[Source: architecture/data-models.md]
- **Live Binance Trade Events** (from WebSocket): Standard Binance trade stream format with timestamp, price, quantity, and side
- **Live Binance Depth Events** (from WebSocket): Standard Binance depth stream format with bid/ask arrays and sequence numbers
- **Captured Golden Sample Format**: Raw JSON messages with additional metadata (capture timestamp, message type annotation)

### Component Specifications
[Source: architecture/components.md#component-2-livecapture]
- **Responsibility**: Connect to live Binance combined WebSocket stream and capture "golden sample" of real-time market events
- **Key Interfaces**:
  - **Input**: Symbol (e.g., BTC-USDT), duration to capture
  - **Output**: File containing raw, interleaved JSON events from WebSocket stream
- **Dependencies**: None. Runs as standalone utility
- **Technology Stack**: Python, `websockets` library

### File Locations
[Source: architecture/source-tree.md]
- Main source code goes in: `src/rlx_datapipe/capture/`
- CLI entry point goes in: `scripts/run_capture.py`
- Tests go in: `tests/capture/`
- Captured data output goes in: `data/golden_sample/` (gitignored)

### API Specifications
[Source: FR3 and Component 2 specifications]
- **Binance WebSocket Endpoint**: `wss://stream.binance.com:9443/ws/btcusdt@trade/btcusdt@depth@100ms`
- **Expected Message Types**:
  - Trade events: `{"e":"trade","E":timestamp,"s":"BTCUSDT","t":tradeId,"p":"price","q":"quantity","b":buyerOrderId,"a":sellerOrderId,"T":tradeTime,"m":isBuyerMaker,"M":ignore}`
  - Depth events: `{"e":"depthUpdate","E":timestamp,"s":"BTCUSDT","U":firstUpdateId,"u":finalUpdateId,"b":[["price","quantity"]],"a":[["price","quantity"]]}`

### Testing Requirements
[Source: architecture/test-strategy.md]
- Test file location: `tests/capture/test_live_capture.py`
- Use Pytest framework exclusively
- Create unit tests using mocked WebSocket connections
- Test network error handling and recovery scenarios
- Integration tests should capture small sample and validate file output

### Technical Constraints
[Source: architecture/tech-stack.md, architecture/coding-standards.md]
- Python 3.10+ required
- Use `websockets` library for WebSocket connections
- All functions must have type hints and docstrings
- No hardcoded values - use configuration or command-line arguments
- Follow PEP 8 style guide with Black formatting and Ruff linting
- Use Loguru for structured logging

### Error Handling Strategy
[Source: architecture/error-handling-strategy.md]
- Configuration errors: Fail fast at startup if critical configurations are missing
- Network connection errors: Log errors and implement connection recovery with exponential backoff
- Data ingestion errors: Log warnings for malformed messages but continue capture
- Use structured logging via Loguru to capture all errors with context

### Project Structure Notes
The capture module follows the established pattern from the analysis module, with proper separation of concerns:
- WebSocket client logic in dedicated module
- File I/O operations in separate module
- CLI interface in scripts directory
- Comprehensive test coverage mirroring src structure

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-07-17 | 1.0 | Initial story creation | Scrum Master |

## Dev Agent Record

### Agent Model Used
[To be filled by Dev Agent]

### Debug Log References
[To be filled by Dev Agent]

### Completion Notes List
[To be filled by Dev Agent]

### File List
[To be filled by Dev Agent]

## QA Results
[To be filled by QA Agent]